#include"Plants.h"


Plants::Plants(GLuint program, std::string start, 
	std::map<char, std::vector<std::string>> rules, int iterNum)
{
	Plants::start = start;
	Plants::rules = rules;
	Plants::iterNum = iterNum;
	Plants::program = program;
}

void Plants::iteration()
{
	std::string::iterator sIt;
	std::map<char, std::vector<std::string>>::iterator mIt;
	result = start;
	for (int i = 0; i < iterNum; i++)
	{
		std::string temp = "";
		for (sIt = result.begin(); sIt != result.end(); sIt++)
		{
			mIt = rules.find(*sIt);
			if (mIt != rules.end())
			{
				int ruleIndex = rand() % (mIt->second.size());
				temp = temp + mIt->second[ruleIndex];
			}
			else
			{
				temp = temp + *sIt;
			}
		}
		result = temp;
	}

	totalLevel = 0;
	int level = 0;
	for (sIt = result.begin(); sIt != result.end(); sIt++)
	{
		if (*sIt == '[')
		{
			level++;
			if (level > totalLevel)
			{
				totalLevel = level;
			}
		}
		else if (*sIt == ']')
		{
			level--;
		}
	}
	//std::cout << "Result String: " << result << std::endl;
}

Transform* Plants::construct()
{
	//Transform(glm::mat4 initial, GLuint animate, int cullingLevel,
		//float cullingRadius, Camera * camera);//Node* child
	float lFactor, rFactor;
	int currLevel = 0;
	glm::mat4 R = glm::mat4(1), T = glm::mat4(1), S = glm::mat4(1);
	Transform* plant = new Transform(T, 0, 0, 0, camera);//Node* child;
	Transform* trunk2tree;
	Trunk* trunk;
	Leaf* leaf;
	GLfloat cosTheta;
	State currState, nextState;
	glm::vec3 nextPos, nextDir, axis;
	glm::vec3 originDir = glm::vec3(0.0f, 1.0f, 0.0f);
	std::stack<State> forks;
	std::string::iterator sIt;
	leaves.clear();

	for (sIt = result.begin(); sIt != result.end(); sIt++)
	{
		switch (*sIt)
		{
		case 'D':
		case 'F': // trunk
			if (currLevel < totalLevel) // branch
			{
				/*
				if (originDir.y - currState.dir.y > 0.0001)
				{
					axis = glm::cross(originDir, currState.dir);
					cosTheta = glm::dot(originDir, currState.dir);
					R = glm::rotate(glm::acos(cosTheta), axis);
				}
				else
				{
					R = glm::mat4(1);
				}

				
				T = glm::translate((float)0.5 * (nextPos + currState.pos));

				S = glm::scale(glm::vec3(1.0f * factor, trunkLength * factor, 1.0f * factor));
*/
				lFactor = (float)pow(lengthFactor, currLevel);
				rFactor = (float)pow(radiusFactor, currLevel);
				nextPos = lFactor * trunkLength * currState.dir + currState.pos;
				//trunk2tree = new Transform(T * R * S, 0, 0, 0, camera);//Node* child
				//trunk2tree->addChild(trunk);
				trunk = new Trunk(rFactor * radiusFactor * trunkRadius, 
					rFactor * trunkRadius, lFactor * trunkLength, 
					currState, trunkTexID, trunkTexLoc);
				//plant->addChild(trunk2tree);
				plant->addChild(trunk);
				currState.pos = nextPos;
			}
			else // leaves
			{
				leaves.push_back(currState);
				leaf = new Leaf(leafLength, currState, leafTexID, leafTexLoc);
				plant->addChild(leaf);
			}
			
			break;

		case 'X': // leaf

			break;

		case '+': // Z axis, CCW
			//zRotate++;
			R = glm::rotate(glm::radians(zUnitDegree), glm::vec3(0.0f, 0.0f, 1.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '-': // Z axis, CW
			//zRotate--;
			R = glm::rotate(glm::radians(-zUnitDegree), glm::vec3(0.0f, 0.0f, 1.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '&': // Y axis, CCW
			//yRotate++;
			R = glm::rotate(glm::radians(yUnitDegree), glm::vec3(0.0f, 1.0f, 0.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '^': // Y axis, CW
			//yRotate--;
			R = glm::rotate(glm::radians(-yUnitDegree), glm::vec3(0.0f, 1.0f, 0.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '*': // X axis, CCW
			//xRotate++;
			R = glm::rotate(glm::radians(xUnitDegree), glm::vec3(1.0f, 0.0f, 0.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '/': // X axis, CW
			//xRotate--;
			R = glm::rotate(glm::radians(-xUnitDegree), glm::vec3(1.0f, 0.0f, 0.0f));
			currState.dir = R * glm::vec4(currState.dir, 0);
			currState.dir = glm::normalize(currState.dir);
			break;

		case '[':
			forks.push(currState);
			currLevel++;
			break;

		case ']':
			currState = forks.top();
			forks.pop();
			currLevel--;
			break;

		default:
			//std::cout << "Undifined character: " << *sIt << std::endl;
			break;
		}
	}

	return plant;
}

/****************************************/
Tree::Tree(GLuint program, Camera* camera)
{
	Tree::camera = camera;
	Tree::program = program;
}

Transform* Tree::oak()
{
	Trunk* trunk = new Trunk();
	Leaf* leaf = new Leaf();
	GLuint trunkTexID, trunkTexLoc = 0;
	GLuint leafTexID, leafTexLoc = 1;

	std::string file = "texture/bark_s.jpg";
	trunkTexID = loadTexture(file, trunkTexLoc);
	trunk->setParameter(program, camera);
	
	file = "texture/flower_s.png";
	leafTexID = loadTexture(file, leafTexLoc);
	leaf->setParameter(program, camera);

	srand((unsigned)time(NULL));
	std::string start = "F[*&X][+^X][/^X]";
	//std::string start = "X";
	std::vector<std::string> ruleX
	{
		"F[*^D][/&D][-&D][+^D]",
		"F[/^D][+&D][-&D][*^D]"
		//"F-[[X]+X]+F[+FX]-X"
	};
	std::vector<std::string> ruleF{ "F" };
	std::vector<std::string> ruleD{ "F[*&X][+^FX][/^X]" };
	std::map<char, std::vector<std::string>> rules =
	{
		{'F', ruleF},
		{'X', ruleX},
		{'D', ruleD}
	};
	int iterNum = 5;

	newTree = new Plants(program, start, rules, iterNum);
	newTree->leafLength = 0.4;
	//newTree->setTrunk(obj);
	newTree->setCamera(camera);
	newTree->setTex(trunkTexID,trunkTexLoc,leafTexID,leafTexLoc);

	newTree->iteration();
	oakTree = newTree->construct();

	//Add particles effect
	Particles* fallingLeaves = new Particles();
	fallingLeaves->loadTexture("texture/flower_s.png", 0);
	fallingLeaves->initial(newTree->getLeaves());
	oakTree->addChild(fallingLeaves);

	return oakTree;
}

Transform* Tree::getTree()
{
	return oak();
}

GLuint Tree::loadTexture(std::string file, GLuint texStoreLoc)
{
	glUseProgram(program);
	GLuint texture;
	glGenTextures(1, &texture);
	glActiveTexture(GL_TEXTURE0 + texStoreLoc);
	glBindTexture(GL_TEXTURE_2D, texture);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	int width, height, nrChannels;
	unsigned char* data = imread(file.c_str(), &width, &height, &nrChannels, 0);
	if (data)
	{
		if (nrChannels == 4)
		{
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
		}
		else
		{
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
		}
		
		glGenerateMipmap(GL_TEXTURE_2D);
	}
	else
	{
		std::cout << "Failed to load texture" << std::endl;
	}
	imfree(data);

	glGenerateMipmap(texture);

	return texture;
}

/******************************************/
GLuint Trunk::program, Trunk::modelLoc, Trunk::viewLoc, Trunk::projectionLoc; 
Camera* Trunk::camera;
Trunk::Trunk(GLfloat upR, GLfloat lowR, GLfloat length, State state, GLuint textureID, GLuint textureLoc)
{
	Trunk::textureID = textureID;
	Trunk::texStoreLoc = textureLoc;
	glm::mat4 R = glm::mat4(1), T = glm::mat4(1);
	glm::vec3 axis, originDir = glm::vec3(0.0f, 1.0f, 0.0f);
	GLfloat cosTheta;

	if (originDir.y - state.dir.y > 0.0001)
	{
		axis = glm::cross(originDir, state.dir);
		cosTheta = glm::dot(originDir, state.dir);
		R = glm::rotate(glm::acos(cosTheta), axis);
	}
	else
	{
		R = glm::mat4(1);
	}


	T = glm::translate((float)0.5 * length * state.dir + state.pos);

	currentModel = T * R;


	glUseProgram(program);
	initialization(upR, lowR, length);
	Trunk::state = state;

	// Generate a vertex array (VAO), vertex buffer objects (VBO) and EBO.
	glGenVertexArrays(1, &vao);
	glGenBuffers(3, vbos);
	glGenBuffers(1, &ebo);

	// Bind to the VAO.
	glBindVertexArray(vao);

	// Bind to the first VBO. We will use it to store the vertices.
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * points.size(), points.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(0);
	//d. How to read VBO
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);


	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[1]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * pointsNormal.size(), pointsNormal.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(1);
	//d. How to read VBO
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);


	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[2]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * texCoord.size(), texCoord.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(2);
	//d. How to read VBO
	glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0);

	//a. Bind to the EBO. We will use it to store the indices.
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
	//b. Pass in the data.
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(glm::ivec3) * faces.size(), faces.data(), GL_STATIC_DRAW);

	// Unbind from the VBO.
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	// Unbind from the VAO.
	glBindVertexArray(0);
}

Trunk::~Trunk()
{

}

void Trunk::draw(glm::mat4 model)
{
	glUseProgram(program);
	setShaderPara(model);
	glDisable(GL_CULL_FACE);
	// Bind to the VAO.
	glBindVertexArray(vao);
	// Draw triangles using the indices in the second VBO, which is an 
	// elemnt array buffer.
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	glActiveTexture(GL_TEXTURE0 + texStoreLoc);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glDrawElements(GL_TRIANGLES, faces.size() * 3, GL_UNSIGNED_INT, 0); // mode, count, type, indices
	// Unbind from the VAO.
	glBindVertexArray(0);
}

void Trunk::update()
{

}

void Trunk::setShaderPara(glm::mat4 model)
{
	glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model * currentModel));
	glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(camera->getViewMatrix()));
	glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(camera->getProjectionMatrix()));
	glUniform1i(glGetUniformLocation(program, "barkTex"), texStoreLoc);
	glUniform1i(glGetUniformLocation(program, "type"),1);
	
}

void Trunk::setCamera(Camera* camera)
{
	Trunk::camera = camera;
}

void Trunk::initialization(GLfloat upR, GLfloat lowR, GLfloat length)
{
	glm::vec3 upPoint, lowPoint;
	glm::vec3 normal;
	double theta;
	
	for (int i = 0; i <= samplingTimes; i++)
	{
		theta = glm::radians((float)i * 360.f / (float)samplingTimes);

		upPoint.x = upR*glm::cos(theta);
		upPoint.y = length / 2;
		upPoint.z = upR * glm::sin(theta);
		points.push_back(upPoint);
		texCoord.push_back(glm::vec2((float)i/ (float)samplingTimes, 1.0));

		lowPoint.x = lowR * glm::cos(theta);
		lowPoint.y = -length / 2;
		lowPoint.z = lowR * glm::sin(theta);
		points.push_back(lowPoint);
		texCoord.push_back(glm::vec2((float)i / (float)samplingTimes, 0.0));

		normal = glm::cross(upPoint, upPoint - lowPoint);
		normal = glm::cross(upPoint - lowPoint, normal);
		normal = glm::normalize(normal);
		pointsNormal.push_back(normal);
		pointsNormal.push_back(normal);

		if (i < samplingTimes)
		{
			faces.push_back(glm::ivec3(2 * i, 2 * i + 1, 2 * i + 2));
			faces.push_back(glm::ivec3(2 * i + 3, 2 * i + 2, 2 * i + 1));
		}
		
	}
}

void Trunk::setParameter(GLuint programID, Camera* camera)
{
	program = programID;
	Trunk::camera = camera;

	glUseProgram(program);
	modelLoc = glGetUniformLocation(program, "model");
	viewLoc = glGetUniformLocation(program, "view");
	projectionLoc = glGetUniformLocation(program, "projection");
}

/**************************************************************************/

GLuint Leaf::program, Leaf::modelLoc, Leaf::viewLoc, Leaf::projectionLoc;
Camera* Leaf::camera;
Leaf::Leaf(GLfloat length, State state, GLuint textureID, GLuint texStoreLoc)
{
	Leaf::textureID = textureID;
	Leaf::texStoreLoc = texStoreLoc;
	glm::mat4 R = glm::mat4(1), T = glm::mat4(1);
	glm::vec3 axis, originDir = glm::vec3(0.0f, 1.0f, 0.0f);
	GLfloat cosTheta;

	if (originDir.y - state.dir.y > 0.0001)
	{
		axis = glm::cross(originDir, state.dir);
		cosTheta = glm::dot(originDir, state.dir);
		R = glm::rotate(glm::acos(cosTheta), axis);
	}
	else
	{
		R = glm::mat4(1);
	}


	T = glm::translate((float)0.5 * length * state.dir + state.pos);

	currentModel = T * R;


	glUseProgram(program);
	initialization(length);
	Trunk::state = state;

	// Generate a vertex array (VAO), vertex buffer objects (VBO) and EBO.
	glGenVertexArrays(1, &vao);
	glGenBuffers(3, vbos);
	glGenBuffers(1, &ebo);

	// Bind to the VAO.
	glBindVertexArray(vao);

	// Bind to the first VBO. We will use it to store the vertices.
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * points.size(), points.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(0);
	//d. How to read VBO
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);


	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[1]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * pointsNormal.size(), pointsNormal.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(1);
	//d. How to read VBO
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);


	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[2]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * texCoord.size(), texCoord.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(2);
	//d. How to read VBO
	glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0);

	//a. Bind to the EBO. We will use it to store the indices.
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
	//b. Pass in the data.
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(glm::ivec3) * faces.size(), faces.data(), GL_STATIC_DRAW);

	// Unbind from the VBO.
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	// Unbind from the VAO.
	glBindVertexArray(0);
}

Leaf::~Leaf()
{

}

void Leaf::draw(glm::mat4 model)
{
	glUseProgram(program);
	setShaderPara(model);
	glDisable(GL_CULL_FACE);
	// Bind to the VAO.
	glBindVertexArray(vao);
	// Draw triangles using the indices in the second VBO, which is an 
	// elemnt array buffer.
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	glActiveTexture(GL_TEXTURE0+texStoreLoc);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glDrawElements(GL_TRIANGLES, faces.size() * 3, GL_UNSIGNED_INT, 0); // mode, count, type, indices
	// Unbind from the VAO.
	glBindVertexArray(0);
}

void Leaf::update()
{

}

void Leaf::setShaderPara(glm::mat4 model)
{
	glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model * currentModel));
	glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(camera->getViewMatrix()));
	glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(camera->getProjectionMatrix()));
	glUniform1i(glGetUniformLocation(program, "leafTex"), texStoreLoc);
	glUniform1i(glGetUniformLocation(program, "type"), 2);

}

void Leaf::setCamera(Camera* camera)
{
	Leaf::camera = camera;
}

void Leaf::initialization(GLfloat length)
{
	glm::vec3 upPoint, lowPoint;
	glm::vec3 normal;
	double theta;
	GLfloat halfL = length / 2;
	points = {glm::vec3(-halfL, +halfL, 0.0),
				glm::vec3(-halfL, -halfL, 0.0), 
				glm::vec3(+halfL, +halfL, 0.0), 
				glm::vec3(+halfL, -halfL, 0.0) };

	pointsNormal = { glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0)};

	faces = { glm::ivec3(0,1,2),glm::ivec3(3,2,1) };

	texCoord = { glm::vec2(1.0, 0.0),
				glm::vec2(1.0, 1.0),
				glm::vec2(0.0, 0.0),
				glm::vec2(0.0, 1.0) };
}

void Leaf::setParameter(GLuint programID, Camera* camera)
{
	program = programID;
	Leaf::camera = camera;

	glUseProgram(program);
	modelLoc = glGetUniformLocation(program, "model");
	viewLoc = glGetUniformLocation(program, "view");
	projectionLoc = glGetUniformLocation(program, "projection");
}

/****************************************************************/
Camera* Particles::camera;
GLuint Particles::programID, Particles::modelLoc, Particles::viewLoc, Particles::projectionLoc;
void Particles::initial(std::vector<State> sources)
{
	Particles::sources = sources;
	maxParticles = sources.size();
	
	for (int i = 0; i < maxParticles; i++)
	{
		Particle newParticle;
		newParticle.pos = sources[i].pos;
		centers.push_back(sources[i].pos);
		newParticle.speed = glm::vec3(0);

		glm::vec3 axis, originDir = glm::vec3(0.0f, 1.0f, 0.0f);
		GLfloat cosTheta;
		if (originDir.y - sources[i].dir.y > 0.0001)
		{
			axis = glm::cross(originDir, sources[i].dir);
			cosTheta = glm::dot(originDir, sources[i].dir);
			newParticle.roatateMatrix = glm::rotate(glm::acos(cosTheta), axis);
		}
		else
		{
			newParticle.roatateMatrix = glm::mat4(1);
		}
		newParticle.life = -1.0;
		particlesContainer.push_back(newParticle);
	}

	float halfL = 0.1;
	points = { glm::vec3(-halfL, +halfL, 0.0),
				glm::vec3(-halfL, -halfL, 0.0),
				glm::vec3(+halfL, +halfL, 0.0),
				glm::vec3(+halfL, -halfL, 0.0) };

	pointsNormal = { glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0),
				glm::vec3(0,0,1.0) };

	faces = { glm::ivec3(0,1,2),glm::ivec3(3,2,1) };

	texCoord = { glm::vec2(1.0, 0.0),
				glm::vec2(1.0, 1.0),
				glm::vec2(0.0, 0.0),
				glm::vec2(0.0, 1.0) };


	glUseProgram(programID);
	
	// Generate a vertex array (VAO), vertex buffer objects (VBO) and EBO.
	glGenVertexArrays(1, &vao);
	glGenBuffers(3, vbos);
	glGenBuffers(1, &ebo);

	// Bind to the VAO.
	glBindVertexArray(vao);

	// Bind to the first VBO. We will use it to store the vertices.
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * points.size(), points.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(0);
	//d. How to read VBO
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);

	//normals
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[1]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * pointsNormal.size(), pointsNormal.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(1);
	//d. How to read VBO
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);

	//texture corrdinate
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[2]);
	//b. Pass in the data.
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * texCoord.size(), texCoord.data(), GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(2);
	//d. How to read VBO
	glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0);

	//centers
	//a. Bind buffer to VAO
	glBindBuffer(GL_ARRAY_BUFFER, vbos[3]);
	//b. initialize with empty buffer
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * maxParticles, NULL, GL_STATIC_DRAW);
	// c. Enable vertex attribute 0. Creat channel
	// We will be able to access vertices through it.
	glEnableVertexAttribArray(3);
	//d. How to read VBO
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);

	//a. Bind to the EBO. We will use it to store the indices.
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
	//b. Pass in the data.
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(glm::ivec3) * faces.size(), faces.data(), GL_STATIC_DRAW);

	// Unbind from the VBO.
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	// Unbind from the VAO.
	glBindVertexArray(0);

	lastTime = glfwGetTime();
}

void Particles::draw(glm::mat4 model)
{
	glUseProgram(programID);
	setShaderPara(model);
	glDisable(GL_CULL_FACE);
	// Bind to the VAO.
	glBindVertexArray(vao);
	// Draw triangles using the indices in the second VBO, which is an 
	// elemnt array buffer.
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, textureID);

	//glDrawElements(GL_TRIANGLES, faces.size() * 3, GL_UNSIGNED_INT, 0); // mode, count, type, indices
	
	glVertexAttribDivisor(0, 0); // vertices : always reuse the same 4 vertices -> 0
	glVertexAttribDivisor(1, 0); // normals
	glVertexAttribDivisor(2, 0); // tex coord
	glVertexAttribDivisor(3, 1); // centers : one per quad (its center)
	
	glDrawElementsInstanced(GL_TRIANGLES, faces.size() * 3, GL_UNSIGNED_INT, 0, particlesCount);
																		
	// Unbind from the VAO.
	glBindVertexArray(0);
}


void Particles::setShaderPara(glm::mat4 model)
{
	glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
	glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(camera->getViewMatrix()));
	glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(camera->getProjectionMatrix()));
	glUniform1i(glGetUniformLocation(programID, "leafTex"), 0);
	//glUniform1i(glGetUniformLocation(programID, "type"), 2);
}

void Particles::update()
{
	GLfloat time = glfwGetTime();
	GLfloat deltaT = time - lastTime;
	lastTime = time;

	int newparticles = (int)(deltaT * 200.0);
	//if (newparticles > (int)(0.016f * 10.0))
		//newparticles = (int)(0.016f * 10.0);

	for (int i = 0; i < newparticles; i++) {
		int particleIndex = findUnusedParticle();
		particlesContainer[particleIndex].life = 200.0f; // This particle will live 5 seconds.
		particlesContainer[particleIndex].pos = sources[particleIndex].pos;

		//float spread = 1.5f;
		glm::vec3 maindir = glm::vec3(-1.0f, 0.0f, 0.0f);
		
		glm::vec3 randomdir = glm::vec3(
			((float)rand() / (float)RAND_MAX) - 1.0,
			((float)rand() / (float)RAND_MAX) - 1.0,
			((float)rand() / (float)RAND_MAX) - 1.0
		);

		particlesContainer[particleIndex].speed = maindir + randomdir;
	}

	particlesCount = 0;
	for (int i = 0; i < maxParticles; i++) {

		Particle& p = particlesContainer[i]; // shortcut

		if (p.life > 0.0f) {

			// Decrease life
			p.life -= deltaT;
			if (p.life > 0.0f) {

				// Simulate simple physics : gravity only, no collisions
				p.speed += glm::vec3(0.0f, -9.81f, 0.0f) * (float)deltaT * 0.5f;
				p.pos += p.speed * (float)deltaT;
				//ParticlesContainer[i].pos += glm::vec3(0.0f,10.0f, 0.0f) * (float)delta;
				if (p.pos.y > 0)
				{
					// Fill the GPU buffer
					centers[particlesCount] = p.pos;
				}
				else
				{
					p.life = -0.1;
				}
			}
			else {
				// Particles that just died will be put at the end of the buffer in SortParticles();
				//p.cameradistance = -1.0f;
			}

			particlesCount++;
		}
	}

	glUseProgram(programID);
	glBindBuffer(GL_ARRAY_BUFFER, vbos[3]);
	glBufferData(GL_ARRAY_BUFFER, maxParticles * 3 * sizeof(GLfloat), NULL, GL_STREAM_DRAW); // Buffer orphaning
	glBufferSubData(GL_ARRAY_BUFFER, 0, particlesCount * sizeof(GLfloat) * 3, centers.data());

}

void Particles::loadTexture(std::string file, GLuint texStoreLoc)
{
	glUseProgram(programID);
	//GLuint texture;
	glGenTextures(1, &textureID);
	glActiveTexture(GL_TEXTURE0 + texStoreLoc);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	int width, height, nrChannels;
	unsigned char* data = imread(file.c_str(), &width, &height, &nrChannels, 0);
	if (data)
	{
		if (nrChannels == 4)
		{
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
		}
		else
		{
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
		}

		glGenerateMipmap(GL_TEXTURE_2D);
	}
	else
	{
		std::cout << "Failed to load texture" << std::endl;
	}
	imfree(data);

	glGenerateMipmap(textureID);

}

int Particles::findUnusedParticle()
{
	for (int i = LastUsedParticle; i < maxParticles; i++) {
		if (particlesContainer[i].life < 0) {
			LastUsedParticle = i;
			return i;
		}
	}

	for (int i = 0; i < LastUsedParticle; i++) {
		if (particlesContainer[i].life < 0) {
			LastUsedParticle = i;
			return i;
		}
	}

	return 0;
}

void Particles::setParameters(GLuint programID, Camera* camera) 
{
	Particles::programID = programID;
	Particles::camera = camera;

	glUseProgram(programID);
	modelLoc = glGetUniformLocation(programID, "model");
	viewLoc = glGetUniformLocation(programID, "view");
	projectionLoc = glGetUniformLocation(programID, "projection");
}